<style>
    .leaderboard-container {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        position: relative;
    }
    
    /* Scrollbar styling for better UX */
    .leaderboard-container::-webkit-scrollbar {
        height: 8px;
    }
    
    .leaderboard-container::-webkit-scrollbar-track {
        background: #2a2a2a;
        border-radius: 4px;
    }
    
    .leaderboard-container::-webkit-scrollbar-thumb {
        background: #4dcdc4;
        border-radius: 4px;
    }
    
    .leaderboard-container::-webkit-scrollbar-thumb:hover {
        background: #3a9d96;
    }
    
    .leaderboard-table {
        width: fit-content; /* Fit content width */
        margin: 0 auto; /* Center the table */
        border-collapse: collapse;
        background: #1e1e1e;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        border-radius: 8px;
        overflow: hidden;
    }
    
    .leaderboard-table thead {
        background: linear-gradient(135deg, #3a9d96 0%, #2c6963 100%);
        color: white;
    }
    
    .leaderboard-table th {
        padding: 16px 12px;
        text-align: center !important;
        font-weight: 600;
        font-size: 14px;
        position: relative;
        white-space: nowrap;
    }
    
    .leaderboard-table tbody tr {
        border-bottom: 1px solid #333;
        transition: background-color 0.2s;
    }
    
    .leaderboard-table tbody tr:hover {
        background-color: #2a2a2a;
    }
    
    
    .leaderboard-table td {
        padding: 16px 12px;
        text-align: center;
        font-size: 14px;
        color: #e0e0e0;
    }
    
    
    .leaderboard-table .rank-cell {
        font-weight: 700;
        font-size: 24px;
        color: #4dcdc4;
        width: 80px;
        min-width: 80px;
        max-width: 80px;
    }
    
    .leaderboard-table .model-cell {
        text-align: center;
        font-weight: 400 !important;
        color: #ffffff;
        min-width: 160px;
        max-width: 180px;
    }
    
    .leaderboard-table .model-cell.top-method {
        font-weight: 700 !important;
    }
    
    .leaderboard-table .badge-cell {
        width: 45px;
        min-width: 45px;
        max-width: 45px;
        text-align: center;
        padding: 16px 4px;
    }
    
    .model-badge {
        display: inline-block;
        font-size: 10px;
        font-weight: 500;
        color: white;
        padding: 2px 5px;
        border-radius: 8px;
        line-height: 1.2;
    }
    
    .model-badge.ar {
        background-color: #B93413;
    }
    
    .model-badge.dllm {
        background-color: #193D3A;
    }
    
    .leaderboard-table .metric-cell {
        min-width: 140px;
        max-width: 160px;
    }
    
    .aup-score {
        font-size: 20px;
        font-weight: 700;
        color: #4ECEC5;
        display: block;
        margin-bottom: 4px;
    }
    
    .sub-metrics {
        font-size: 11px;
        color: #999;
        display: block;
    }
    
    /* White color for top 2 methods */
    .sub-metrics.top-method {
        color: #ffffff;
    }
    
    /* Light gray for other methods */
    .sub-metrics.other-method {
        color: #aaa;
    }
    
    .avg-cell {
        background-color: #1a3d3a;
        font-weight: 700;
        min-width: 120px;
        max-width: 140px;
    }
    
    .avg-cell .aup-score {
        font-size: 22px;
        color: #43bfb7;
    }
    
    .na-value {
        color: #666;
        font-size: 18px;
    }
    
    /* Rank badges */
    .rank-badge {
        display: inline-block;
        line-height: 1;
    }
    
    .rank-medal {
        font-size: 36px;
        display: inline-block;
        line-height: 1;
    }
    
    .rank-number {
        font-size: 20px;
        font-weight: 700;
        color: #4dcdc4;
    }
    
    /* Scroll hint for mobile */
    .scroll-hint {
        display: none;
        text-align: center;
        color: #4dcdc4;
        font-size: 12px;
        margin-bottom: 10px;
        padding: 8px;
        background: rgba(77, 205, 196, 0.15);
        border-radius: 4px;
        border: 1px solid rgba(77, 205, 196, 0.3);
    }
    
    @media (max-width: 768px) {
        .scroll-hint {
            display: block;
        }
        
        .leaderboard-container {
            margin: 20px -15px; /* Extend to screen edges on mobile */
            padding: 0 15px;
        }
        
        .leaderboard-table {
            font-size: 11px;
            min-width: auto; /* Remove fixed min-width on mobile */
            width: max-content; /* Fit content exactly */
        }
        
        .leaderboard-table th,
        .leaderboard-table td {
            padding: 8px 6px;
        }
        
        .aup-score {
            font-size: 15px;
        }
        
        .sub-metrics {
            font-size: 9px;
        }
        
        .rank-medal {
            font-size: 28px;
        }
        
        .rank-number {
            font-size: 16px;
        }
        
        
        .leaderboard-table .rank-cell {
            width: 60px;
            min-width: 60px;
            max-width: 60px;
        }
        
        .leaderboard-table .badge-cell {
            width: 38px;
            min-width: 38px;
            max-width: 38px;
            padding: 8px 2px;
        }
        
        .leaderboard-table .model-cell {
            min-width: 120px;
            max-width: 140px;
        }
        
        .model-badge {
            font-size: 7px;
            padding: 1px 4px;
        }
        
        .leaderboard-table .metric-cell {
            min-width: 110px;
            max-width: 130px;
        }
        
        .avg-cell {
            min-width: 100px;
            max-width: 120px;
        }
    }
    </style>
    
<div style="width: fit-content; max-width: 100%; margin: 30px auto;">
    <div class="scroll-hint">
        ‚Üê Swipe left/right to see all columns ‚Üí
    </div>
    <div class="leaderboard-container">
        <table class="leaderboard-table" id="leaderboard-previous">
        <thead>
            <tr>
                <th>Rank</th>
                <th>Type</th>
                <th>Model</th>
                <th>GSM8K-CoT</th>
                <th>MATH</th>
                <th>MBPP</th>
                <th>HumanEval</th>
                <th>Long-GSM8K</th>
                <th>AUP Score</th>
            </tr>
        </thead>
        <tbody id="leaderboard-body-previous">
            <!-- Data will be populated by JavaScript -->
        </tbody>
    </table>
    </div>
</div>
    
    <script>
    (function() {
        let allData = {};
        
        // Custom order for models - MODIFY THIS ARRAY TO CHANGE THE ORDER
        const AR_or_dLLM = [
            'AR', 
            'dLLM',
            'dLLM',
            'dLLM',
            'dLLM',
            'dLLM',
            'dLLM',
            'AR',
            'dLLM',
            'dLLM',
        ];
        const customOrder = [
            'EAGLE-3 (LLaMA-3.1)',
            'dParallel-LLaDA',
            'dParallel-Dream',
            'Fast-dLLM-v2-7B',
            'Fast-dLLM-LLaDA',
            'D2F',
            'Fast-dLLM-Dream',
            'Qwen-2.5-7B-it',
            'Dream',
            'LLaDA',
        ];
        
        // Parse CSV data
        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const data = {
                "gsm8k_cot": {},
                "math": {},
                "mbpp": {},
                "humaneval": {},
                "long_gsm8k": {}
            };
            
            let headerLine = null;
            let datasetColumns = {}; // Maps column index to dataset name
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const cells = line.split(',');
                
                // Check if this is a header line with dataset names
                if (line.includes('gsm8k_cot') || line.includes('mbpp') || line.includes('humaneval') || line.includes('long-gsm8k')) {
                    headerLine = i;
                    datasetColumns = {};
                    
                    // Map column indices to dataset names
                    for (let j = 0; j < cells.length; j++) {
                        const cell = cells[j].trim();
                        if (cell === 'gsm8k_cot') {
                            datasetColumns[j] = 'gsm8k_cot';
                        } else if (cell === 'math' && !cells.join(',').includes('long-gsm8k')) {
                            datasetColumns[j] = 'math';
                        } else if (cell === 'mbpp_instruct' || cell === 'mbpp') {
                            datasetColumns[j] = 'mbpp';
                        } else if (cell === 'humaneval_instruct' || cell === 'humaneval') {
                            datasetColumns[j] = 'humaneval';
                        } else if (cell === 'long-gsm8k') {
                            datasetColumns[j] = 'long_gsm8k';
                        }
                    }
                    continue;
                }
                
                // Skip header rows with "token/forward (TPF)"
                if (line.includes('token/forward (TPF)')) {
                    continue;
                }
                
                // Parse data rows
                if (cells.length > 4 && cells[1] && headerLine !== null) {
                    const modelName = cells[1].trim();
                    
                    // Skip section headers and empty model names
                    if (modelName && 
                        !modelName.includes('Dream:') && 
                        !modelName.includes('LLaDA:') && 
                        !modelName.includes('Dream Coder:') && 
                        !modelName.includes('TPS:') &&
                        !modelName.includes('Qwen2.5-Coder-7B') &&
                        !modelName.includes('d3LLM') &&
                        !modelName.includes('Coder')) {
                        
                        // Parse data for each dataset in this row
                        for (let colIdx in datasetColumns) {
                            const dataset = datasetColumns[colIdx];
                            const baseCol = parseInt(colIdx);
                            
                            const tpf = parseFloat(cells[baseCol]);
                            const acc = parseFloat(cells[baseCol + 1]);
                            const aup = parseFloat(cells[baseCol + 2]);
                            
                            if (!isNaN(tpf) && !isNaN(acc) && !isNaN(aup)) {
                                data[dataset][modelName] = [tpf, acc, aup];
                            }
                        }
                    }
                }
            }
            
            return data;
        }
        
        // Load CSV file
        async function loadData() {
            try {
                const response = await fetch('/blogs/text-diffusion/dLLM_Results.csv');
                const csvText = await response.text();
                allData = parseCSV(csvText);
                
                // Initialize and render table
                const processedData = processData(allData);
                const orderedData = orderData(processedData);
                renderTable(orderedData);
            } catch (error) {
                console.error('Error loading CSV:', error);
                document.getElementById('leaderboard-body-previous').innerHTML = 
                    '<tr><td colspan="9" style="text-align:center;color:#999;">Error loading data</td></tr>';
            }
        }
        
        function processData(data) {
            const tasks = ['gsm8k_cot', 'math', 'mbpp', 'humaneval', 'long_gsm8k'];
            const models = {};
            
            // Extract all unique models
            tasks.forEach(task => {
                if (data[task]) {
                    Object.keys(data[task]).forEach(model => {
                        if (!models[model]) {
                            models[model] = {
                                name: model,
                                metrics: {}
                            };
                        }
                    });
                }
            });
            
            // Process metrics for each model
            Object.keys(models).forEach(modelName => {
                let totalAUP = 0;
                const taskCount = tasks.length; // Always count all tasks
                
                tasks.forEach(task => {
                    if (data[task] && data[task][modelName]) {
                        const [tpf, acc, aup] = data[task][modelName];
                        
                        models[modelName].metrics[task] = {
                            aup: aup,
                            tpf: tpf,
                            acc: acc
                        };
                        
                        totalAUP += aup;
                    } else {
                        models[modelName].metrics[task] = null;
                        // Missing values are treated as 0, so no need to add anything
                    }
                });
                
                models[modelName].avgAUP = totalAUP / taskCount;
            });
            
            return Object.values(models);
        }
        
        function orderData(data) {
            // Create a map for quick lookup
            const dataMap = {};
            data.forEach(model => {
                dataMap[model.name] = model;
            });
            
            // Order according to customOrder array
            const orderedData = [];
            customOrder.forEach(modelName => {
                if (dataMap[modelName]) {
                    orderedData.push(dataMap[modelName]);
                }
            });
            
            return orderedData;
        }
        
        function formatMetricCell(metric, isTopMethod) {
            if (!metric) {
                return '<span class="na-value">/</span>';
            }
            
            const cssClass = isTopMethod ? 'top-method' : 'other-method';
            
            return `
                <span class="sub-metrics ${cssClass}">Acc: ${metric.acc.toFixed(1)}%</span>
                <span class="sub-metrics ${cssClass}">TPF: ${metric.tpf.toFixed(2)}</span>
            `;
        }
        
        function getRankDisplay(rank) {
            if (rank === 1) {
                return `<span class="rank-badge"><span class="rank-medal">ü•á</span></span>`;
            // } else if (rank === 2) {
            //     return `<span class="rank-badge"><span class="rank-medal">ü•à</span></span>`;
            } else {
                return `<span class="rank-number">${rank}</span>`;
            }
        }
        
        function renderTable(data) {
            const tbody = document.getElementById('leaderboard-body-previous');
            tbody.innerHTML = '';
            
            data.forEach((model, index) => {
                const rank = index + 1;
                const isTopMethod = rank <= 2;
                const row = document.createElement('tr');
                
                const modelCellClass = isTopMethod ? 'model-cell top-method' : 'model-cell';
                
                // Get the type (AR or dLLM) for this model
                const modelType = AR_or_dLLM[index] || 'dLLM';
                const badgeClass = modelType === 'AR' ? 'ar' : 'dllm';
                
                row.innerHTML = `
                    <td class="rank-cell">${getRankDisplay(rank)}</td>
                    <td class="badge-cell"><span class="model-badge ${badgeClass}">${modelType}</span></td>
                    <td class="${modelCellClass}">${model.name}</td>
                    <td class="metric-cell">${formatMetricCell(model.metrics.gsm8k_cot, isTopMethod)}</td>
                    <td class="metric-cell">${formatMetricCell(model.metrics.math, isTopMethod)}</td>
                    <td class="metric-cell">${formatMetricCell(model.metrics.mbpp, isTopMethod)}</td>
                    <td class="metric-cell">${formatMetricCell(model.metrics.humaneval, isTopMethod)}</td>
                    <td class="metric-cell">${formatMetricCell(model.metrics.long_gsm8k, isTopMethod)}</td>
                    <td class="metric-cell avg-cell">
                        <span class="aup-score">${model.avgAUP.toFixed(1)}</span>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        // Load data from CSV
        loadData();
    })();
    </script>
    <!-- Version: 2024-12-04-v2 -->
    